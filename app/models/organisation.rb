class Organisation < ApplicationRecord
  has_paper_trail

  has_many :users, dependent: :destroy
  has_many :api_keys, dependent: :destroy
  has_and_belongs_to_many :roles

  validate :no_duplicate_roles

  enum :status, {
    unregistered: 0,
    authorised: 1,
    pending: 2,
    rejected: 3,
  }

  class << self
    def from_profile!(government_gateway_profile)
      find_or_initialize_by(organisation_id: government_gateway_profile["bas:groupId"]).tap do |organisation|
        if organisation.new_record?
          organisation.description = "Autogenerated on #{Time.zone.now.iso8601}"
          organisation.status = :unregistered

          organisation.save!
        end
      end
    end

    def find_or_associate_implicit_organisation_to(user)
      if user.organisation.blank?
        new(organisation_name: user.email_address).tap do |organisation|
          # TODO: This is for backwards compatibility, remove later when organisations are explicitly managed by the dev portal and not the SCP provider.
          organisation.organisation_id = SecureRandom.uuid.upcase
          organisation.description = "Default implicit organisation for initial user #{user.email_address}"
          organisation.status = :unregistered
          organisation.save!
          organisation.assign_standard_read_role!
          user.organisation = organisation
          user.save!
        end
      end
    end
  end

  def has_role?(role_name)
    roles.exists?(name: role_name)
  end

  Role.role_names.each do |role_name|
    define_method("has_#{role_name.tr(':', '_')}_role?") do
      has_role?(role_name)
    end

    define_method("assign_#{role_name.tr(':', '_')}_role!") do
      role = Role.find_by(name: role_name)
      unless roles.include?(role)
        roles << role
        save!
      end
    end
  end

private

  def no_duplicate_roles
    roles.each do |role|
      if roles.where(id: role.id).size > 1
        errors.add(:roles, "cannot have duplicate #{role.name}")
      end
    end
  end
end
