class CreateApiKey
  CLIENT_ID_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".freeze
  CLIENT_ID_LENGTH = 17
  CLIENT_ID_PREFIX = "HUB".freeze
  SECRET_LENGTH = 48
  API_KEY_TYPE = "API_KEY".freeze
  PLAN_LIST_LIMIT = (ENV["USAGE_PLAN_LIST_PAGINATION_LIMIT"] || "100").to_i
  PER_FPO_RATE_LIMIT = (ENV["USAGE_PLAN_PER_FPO_RATE_LIMIT"] || "100").to_i
  PER_FPO_BURST_LIMIT = (ENV["USAGE_PLAN_PER_FPO_BURST_LIMIT"] || "200").to_i
  REST_API_ID = ENV["REST_API_ID"]
  STAGE_NAME = ENV["REST_STAGE_NAME"]
  TAGS = { customer: "fpo" }.freeze

  def initialize(api_gateway_client = Aws::APIGateway::Client.new)
    @api_gateway_client = api_gateway_client
  end

  def call(organisation_id, description = nil)
    api_key = ApiKey.new
    api_key.organisation_id = organisation_id
    api_key.api_key_id = generate_client_id
    api_key.secret = generate_random_secret
    api_key.enabled = true
    api_key.description = description || "Autogenerated on #{Time.zone.now.utc.iso8601}"

    begin
      create_in_api_gateway(api_key)
      associate_to_usage_plan(api_key)
      api_key.save!
    rescue StandardError => e
      Rails.logger.error("Error creating API key: #{e.message}")
      if api_key.api_gateway_id
        begin
          api_gateway_client.delete_api_key(api_key_id: api_gateway_id)
          Rails.logger.info("Deleted API key #{api_key.api_gateway_id} from AWS due to error")
        rescue StandardError => delete_error
          Rails.logger.error("Failed to delete API key #{api_key.api_gateway_id} from AWS: #{delete_error.message}")
        end
        api_key.destroy! if api_key.persisted? # Shouldn't happen, but just in case
      end

      raise
    end

    api_key
  end

private

  attr_reader :api_gateway_client

  def create_in_api_gateway(api_key)
    response = api_gateway_client.create_api_key(
      name: api_key.api_key_id,
      description: api_key.description,
      enabled: api_key.enabled,
      value: api_key.secret,
    )

    api_key.api_gateway_id = response.id.presence || raise("Failed to create API key")
  end

  def associate_to_usage_plan(api_key)
    usage_plan_id = find_or_create_usage_plan(api_key)
    api_key.usage_plan_id = usage_plan_id
    api_gateway_client.create_usage_plan_key(
      key_id: api_key.api_gateway_id,
      key_type: API_KEY_TYPE,
      usage_plan_id: api_key.usage_plan_id,
    )
  end

  def find_or_create_usage_plan(api_key)
    find_usage_plan(api_key.organisation.id) ||
      create_usage_plan(api_key.organisation.id)
  end

  def find_usage_plan(organisation_id)
    usage_plans = get_usage_plans
    usage_plan = usage_plans.find { |plan| plan.name == organisation_id }
    usage_plan&.id
  end

  def get_usage_plans
    usage_plans = []
    position = nil

    loop do
      response = api_gateway_client.get_usage_plans(limit: PLAN_LIST_LIMIT, position: position)
      usage_plans.concat(response.items || [])
      position = response.position
      break if position.nil? || (response.items || []).empty?
    end

    usage_plans
  end

  def create_usage_plan(organisation_id)
    response = api_gateway_client.create_usage_plan(
      name: organisation_id,
      description: "Automatically generated usage plan for #{organisation_id}",
      throttle: { rate_limit: PER_FPO_RATE_LIMIT, burst_limit: PER_FPO_BURST_LIMIT },
      api_stages: [{ api_id: REST_API_ID, stage: STAGE_NAME }],
      tags: TAGS,
    )
    response.id
  end

  def generate_client_id
    client_id = CLIENT_ID_PREFIX
    CLIENT_ID_LENGTH.times do
      client_id += CLIENT_ID_CHARS[Kernel.rand(CLIENT_ID_CHARS.length)]
    end
    client_id
  end

  def generate_random_secret
    SecureRandom.hex(SECRET_LENGTH / 2)
  end
end
